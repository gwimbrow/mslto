<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>integration tests</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css" />
  </head>
  <body>
    <div id="mocha"></div>
    <script src="../node_modules/chai/chai.js"></script>
    <script src="../node_modules/mocha/mocha.js"></script>
    <script src="../node_modules/sinon/pkg/sinon.js"></script>
    <script class="mocha-init">
      mocha.setup('bdd');
      mocha.checkLeaks();
    </script>
    <script src="../dist/mslto.min.js"></script>
    <script>
      var expect = chai.expect;

      describe('mslto', function () {
        it('should be defined in the global scope', function () {
          expect(mslto).to.not.equal(undefined);
        });
        it('should expose a "Provider" class', function () {
          expect(mslto.Provider).to.be.a('function');
        });
        describe('Provider Class', function () {
          it('should be a constructor', function () {
            var Provider = mslto.Provider;
            expect(new Provider('{"foo": "bar"}')).to.be.an.instanceOf(Provider);
          });
        });
        describe('Provider Instances', function () {
          it('should expose "data", "state", and "register" properties', function () {
            var Provider = mslto.Provider;
            var instance = new Provider('{"foo": "bar"}');
            expect(instance).to.have.property('data');
            expect(instance).to.have.property('state');
            expect(instance).to.have.property('register');
          });
          it('should accept only JSON data as props', function () {
            var Provider = mslto.Provider;
            expect(new Provider('{"foo": "bar", "boom": ["bap"]}')).to.be.ok;
            expect(() => new Provider('{}')).to.throw('Props cannot be empty');
            expect(() => new Provider('[]')).to.throw('Props cannot be an array');
            expect(() => new Provider('foo')).to.throw();
          });
          it('should expose serialized data through the "data" accessor', function () {
            var model = { foo: 'bar' };
            var Provider = mslto.Provider;
            var instance = new Provider(JSON.stringify(model));
            expect(instance.data).to.equal(JSON.stringify(model));
          });
          it('should assign properties from a provided JSON object to "state"', function () {
            var model = { foo: 'bar' };
            var Provider = mslto.Provider;
            var instance = new Provider(JSON.stringify(model));
            expect(instance.state.foo).to.equal(model.foo);
          });
        });
        describe('Reactivity', function () {
          it('should disallow adding or removing properties for objects', function () {
            var model = { foo: 'bar ' };
            var Provider = mslto.Provider;
            var instance = new Provider(JSON.stringify(model));
            expect(() => delete instance.state.foo).to.throw();
            expect(() => instance.state.boom = 'bap').to.throw();
          });
          it('should trigger a callback function whenever a condition is satisfied', function (done) {
            var model = { x: 0, y: 1 };
            var Provider = mslto.Provider;
            var instance = new Provider(JSON.stringify(model));
            var condition = function (state) {
              return state.x === state.y;
            };
            var callback = function (state) {
              expect(state.x).to.equal(state.y);
              done();
            };
            instance.register(condition, callback);
            instance.state.x = 1;
          });
          describe('for nested objects', function () {
            it('should react to changes', function (done) {
              var model = { foo: { x: 0 }, y: 1 };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model));
              var condition = function (state) {
                return state.foo.x === state.y;
              };
              var callback = function (state) {
                expect(state.foo.x).to.equal(state.y);
                done();
              };
              instance.register(condition, callback);
              instance.state.foo.x = 1
            });
          });
          describe('for arrays', function () {
            it('push', function (done) {
              var model = { foo: [] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model));
              var condition = function (state) {
                return state.foo.length === 1;
              };
              var callback = function (state) {
                expect(state.foo.length).to.equal(1);
                expect(state.foo[0]).to.equal('bar');
                done();
              };
              instance.register(condition, callback);
              instance.state.foo.push('bar');
            });
            it('unshift', function (done) {
              var model = { foo: [] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model));
              var condition = function (state) {
                return state.foo.length === 1;
              };
              var callback = function (state) {
                expect(state.foo[0]).to.equal('bar')
                done();
              };
              instance.register(condition, callback);
              instance.state.foo.unshift('bar');
            });
            it('fill', function (done) {
              var model = { foo: ['bar'] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model));
              var condition = function (state) {
                // set up a more specific condition
                return state.foo.includes('baz');
              };
              var callback = function (state) {
                expect(state.foo).to.deep.equal(['baz']);
                done();
              };
              instance.register(condition, callback);
              instance.state.foo.fill('baz');
            });
            it('copyWithin', function (done) {
              var model = { foo: [0, 1] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model));
              var condition = function (state) {
                return state.foo[0] === 1;
              };
              var callback = function (state) {
                expect(state.foo).to.deep.equal([1, 1]);
                done();
              };
              instance.register(condition, callback);
              instance.state.foo.copyWithin(0, 1);
            });
            it('reverse', function (done) {
              let count = 0;
              var model = { foo: [0, 1] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model));
              var condition = function (state) {
                return !!state.foo;
              };
              var callback = function (state) {
                switch(count++) {
                  case 0: {
                    expect(state.foo[0]).to.equal(1);
                    break;
                  }
                  case 1: {
                    expect(state.foo[1]).to.equal(0);
                    done();
                  }
                }
              };
              instance.register(condition, callback);
              instance.state.foo.reverse();
            });
            it('pop', function (done) {
              var model = { foo: [0, 1] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model));
              var condition = function (state) {
                return state.foo.length === 1;
              }
              var callback = function (state) {
                expect(state.foo.length).to.equal(1);
                done();
              };
              instance.register(condition, callback);
              expect(instance.state.foo.pop()).to.equal(model.foo.pop());
            });
            it('shift', function (done) {
              let count = 0;
              var model = { foo: [0, 1] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model), function (key, oldValue, newValue, deleted) {
                expect(key).to.deep.equal(['foo', count]);
                switch(count++) {
                  case 0: {
                    expect(oldValue).to.equal(0);
                    expect(newValue).to.equal(1);
                    break;
                  }
                  case 1: {
                    expect(oldValue).to.equal(1);
                    expect(newValue).to.equal(undefined);
                    expect(deleted).to.equal(true);
                    done();
                  }
                }
              });
              instance.props.foo.shift();
            });
            it('splice', function (done) {
              let count = 0;
              var model = { foo: [0, 1] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model), function (key, oldValue, newValue, deleted) {
                expect(key).to.deep.equal(['foo', count]);
                switch(count++) {
                  case 0: {
                    expect(oldValue).to.equal(0);
                    expect(newValue).to.equal(1);
                    break;
                  }
                  case 1: {
                    expect(oldValue).to.equal(1);
                    expect(newValue).to.equal(undefined);
                    expect(deleted).to.equal(true);
                    done();
                  }
                }
              });
              instance.props.foo.splice(0, 1);
            });
            it('should not return Proxy objects from the built-in Array methods "pop", "shift", or "splice"', function () {
              var model = { foo: [{ bar: 'baz' }, { boom: 'bap' }, { zig: 'zag' }] };
              var Provider = mslto.Provider;
              var spy = sinon.spy();
              var instance = new Provider(JSON.stringify(model), spy);
              // last element removed; call count = 1
              var popped = instance.props.foo.pop();
              // first element is removed; call count = 2
              // second element is shifted to first index; call count = 3
              var shifted = instance.props.foo.shift();
              // first element is removed; call count = 4
              var spliced = instance.props.foo.splice(0, 1);
              expect(spy.callCount).to.equal(4);
              // updating the values for any of the removed elements should not trigger reactivity.
              // furthermore, we should be allowed to delete properties in those objects.
              delete popped.zig;
              delete shifted.bar;
              delete spliced.boom;
              expect(spy.callCount).to.equal(4);
            });
            it('should not return a Proxy for Array.prototype.slice()', function () {
              var model = { foo: [0, 1] };
              var Provider = mslto.Provider;
              var spy = sinon.spy();
              var instance = new Provider(JSON.stringify(model), spy);
              instance.props.foo[0];
              instance.props.foo.slice()[0] = 'bar';
              expect(spy.called).to.equal(false);
            });
            it('should react to changes for object elements', function (done) {
              var model = { foo: [{bar: 'baz'}] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model), function (key, oldValue, newValue) {
                expect(key).to.deep.equal(['foo', 0, 'bar']);
                expect(oldValue).to.equal(model.foo[0].bar);
                expect(newValue).to.equal('bap');
                done();
              });
              instance.props.foo[0].bar = 'bap';
            });
            it('should react when elements are removed', function (done) {
              var model = { foo: [0] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model), function (key, oldValue, newValue, deleted) {
                expect(key).to.deep.equal(['foo', 0]);
                expect(oldValue).to.equal(model.foo[0]);
                expect(newValue).to.equal(undefined);
                expect(deleted).to.equal(true);
                done();
              });
              instance.props.foo.pop();
            });
            it('should not allow new properties to be defined for object elements', function () {
              var model = { foo: [{ bar: 'baz' }] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model));
              expect(() => instance.props.foo[0].boom = 'bap').to.throw();
            });
            it('should not allow properties to be deleted from object elements', function () {
              var model = { foo: [{ bar: 'baz' }] };
              var Provider = mslto.Provider;
              var instance = new Provider(JSON.stringify(model));
              expect(() => delete instance.props.foo[0].bar).to.throw();
            });
            it('should revoke reactivity for object elements that are removed', function () {
              var model = { foo: [{ bar: 'baz' }] };
              var Provider = mslto.Provider;
              var spy = sinon.spy();
              var instance = new Provider(JSON.stringify(model), spy);
              var removed = instance.props.foo.pop();
              removed.bar = 'bap';
              // the callback will trigger once when the element is removed
              expect(spy.callCount).to.equal(1);
            });
          });
        });
      });
    </script>
    <script class="mocha-exec">
      mocha.run();
    </script>
  </body>
</html>
